---
title: "Spatial and Temporal Continuity at Different Ecological Levels"
author: "Derek Corcoran"
date: "`r Sys.Date()`"
output:
  ioslides_presentation:
    widescreen: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE,
                      error = FALSE,
                      message = FALSE,
                      tidy = 'formatR',
                      cache = T)
library(SpatioTemporalCont)
library(terra)
library(tidyterra)
library(ggplot2)
library(purrr)
library(sdmTMB)
library(sdmTMB)
library(patchwork)
library(kableExtra)
library(DHARMa)
library(GeNetIt)
```

# Connectivity

## Why Connectivity

* Fragmentation is one of the main drivers of biodiversity loss
* It diminishes genetic diversity

```{r, echo = F}
knitr::include_graphics("Images/FragmentationSpp.png")
```

# Continuous connectivity measures

## Geographic vs continuous connectivity

```{r geographiclayers}
RasterMaps <- terra::rast(system.file("extdata/covariates.tif", package="GeNetIt"))
data(ralu.site, package="GeNetIt")
sites <- ralu.site
```

```{r rasterplot, echo =FALSE}
ggplot() + geom_spatraster(data = RasterMaps["err27"]) + geom_spatvector(data = terra::vect(sites), aes(size  = AREA_m2/10000))+ scale_fill_terrain_c(name = "Elevation-Relief Ratio") + scale_size(name = "wetland area [Ha]")
```

## Variables

Rasters:

* **cti**: Compound Topographic Index (“wetness”)
* **err27**: Elevation Relief Ratio
* **ffp**: Frost Free Period
* **gsp**: Growing Season Precipitation
* **hli**: Heat Load Index
* **nlcd**: USGS Landcover (categorical map)

## Conductance in gDistance {.smaller}

Ranked by experts ordinal 1) cti, 2) gsp, 3) ffp, 4) err27  

* *err27*: The elevation relief ratio identifies significant topographic features, higher ERR27 indicate greater topographic change ~ increased resistance. has to be inverted
* *ffp* frost free preriod, the higher the value the more conductivity
* *gsp* Growing Season Precipitation, it has to be more than 196 mm for key species to be present
* *cti* Compound Topographic Index, the higher the more conductivity

```{r costlayer}
err.cost <- (1/RasterMaps[["err27"]])
ffp.cost <- (RasterMaps[["ffp"]]/5)
gsp.cost <- (RasterMaps[["gsp"]]-196)/15
cti.cost <- RasterMaps[["cti"]]/5
cost1 <- (gsp.cost + cti.cost + err.cost + ffp.cost)
```

## conductance and sampling points

```{r, echo = F}
ggplot() + geom_spatraster(data = cost1) + geom_spatvector(data = terra::vect(sites), aes(size  = AREA_m2/10000))+ scale_fill_wiki_c(name = "conductance") + scale_size(name = "wetland area [Ha]")
```

## Generating transition matrices

```{r transitionmatrix}
tr.cost1 <- gdistance::transition(raster::raster(cost1), transitionFunction=mean, directions=8)
tr.cost1 <- gdistance::geoCorrection(tr.cost1,type = "c",multpl=FALSE)
```

## Geographic path  {.smaller}

```{r geographic}
Neighbours <- terra::delaunay(vect(sites), as.lines = T)
```

```{r plot, echo=FALSE}
Transcost <- terra::rast(raster::raster(tr.cost1), crs = terra::crs(terra::vect(sites)))

TerraSites <- terra::vect(sites)

Neighbours <- terra::delaunay(vect(sites), as.lines = T)

ggplot() + geom_spatraster(data = Transcost) + scale_fill_wiki_c(name = "conductance")  + geom_spatvector(data = Neighbours, color = "darkgrey") + geom_spatvector(data = TerraSites, aes(size  = AREA_m2/10000)) + scale_size(name = "wetland area [Ha]")
```

## Add least cost {.smaller}

```{r LeastCostLines}
Lines <- list()

for(i in 1:nrow(Neighbours)){
    Temp <- as.matrix(as.data.frame(terra::intersect(terra::vect(sites), Neighbours[i,]),geom = "XY")[c("x", "y")])
    Lines[[i]] <- terra::vect(sf::st_as_sf(gdistance::shortestPath(tr.cost1, origin = Temp[1,], goal = Temp[2,], output = "SpatialLines")))
    terra::crs(Lines[[i]]) <- terra::crs(Neighbours)
}

Lines <- Lines |> purrr::reduce(rbind)
```

## Add least cost (Plot)

```{r leastCost, echo=FALSE}
ggplot() + geom_spatraster(data = Transcost) + scale_fill_wiki_c(name = "conductance")  + geom_spatvector(data = Neighbours, color = "darkgrey") + geom_spatvector(data = Lines, color = "red") + geom_spatvector(data = TerraSites, aes(size  = AREA_m2/10000)) + scale_size(name = "wetland area [Ha]")
```

## Distance Correlation

```{r Cor, echo = F, cache=TRUE}
DF <- data.frame(euclidean = terra::perim(Neighbours), LeastCost = terra::perim(Lines))

plotly::ggplotly(ggplot(DF, aes(x = euclidean, y = LeastCost)) + geom_point() + geom_abline(intercept = 0, slope = 1, col = "red", lty = 2) + theme_bw())
```

## Actual cost

```{r}
Temp <- as.matrix(as.data.frame(terra::vect(sites),geom = "XY")[c("x", "y")])

DF1 <- GeNetIt::dmatrix.df(as.matrix(gdistance::costDistance(tr.cost1, Temp))) |> dplyr::rename(least_cost = distance)

DF2 <- GeNetIt::dmatrix.df(as.matrix(gdistance::commuteDistance(tr.cost1, Temp)))  |> dplyr::rename(commute_time = distance)

DF3 <- GeNetIt::dmatrix.df(as.matrix(distance(terra::vect(sites)))) |> dplyr::rename(euclidean_dist = distance)


DF4 <- read.csv("https://raw.githubusercontent.com/Sustainscapes/Sustainscapes.github.io/master/SpatialContinuity/data/gdist.csv", header=TRUE) |> 
  dplyr::rename(from = FROM, to = TO, genetic_dist = GDIST) |> 
  dplyr::select(from, to, genetic_dist)

DF <- list(DF1, DF2, DF3, DF4) |> purrr::reduce(full_join)
```

## Comparison

```{r, echo=FALSE, cache = T}
ggplot(DF, aes(x = commute_time, y = least_cost)) + geom_point()
```

## Comparison 2

```{r, echo = F, cache=TRUE}
DF |> tidyr::pivot_longer(least_cost:euclidean_dist, names_to = "dist_type", values_to = "dist") |> ggplot(aes(x = genetic_dist, y = dist)) + geom_point() + geom_smooth() + facet_wrap(~dist_type, scales = "free")
```

# Exercise

## Check connectivity in Denmark {.smaller}

```{r toconnect, eval =TRUE, cache=T}
data("Landuse_DK")
Landuse <- terra::unwrap(Landuse_DK)
## Make sourcers to be dry nature
DryNature <- Landuse

DryNature <- terra::ifel(DryNature == "dry nature", 1, NA)

Patches <- terra::aggregate(DryNature, by = "Landuse") |> 
  as.polygons() |> 
  disagg()

Patches$Area_ha <- terra::expanse(Patches, unit = "ha")

Centroids <- terra::centroids(Patches)

Centroids_DF <- as.data.frame(Centroids, geom = "XY")
```

## Generate new landuse types {.smaller}

```{r, eval = F}
CLS1 <- levels(Landuse)[[1]]

NewCls <- data.frame(ID = c(0, 1), Type = c("Non-nature", "Nature"))

Nature <- as.numeric(Landuse)

Nature <- terra::ifel(Nature %in% c(7,8,11), 1, 0)

Nature <- mask(Nature, Landuse)

levels(Nature) <- NewCls
```

## Exercise

* Choose on of the new maps (`DryNature`, `Nature`)
* Choose one of the Landuses in `Landuse`, and check for different radiuses and generate habitat continuities using `SpatioTemporalCont::calculate_prop`
* Calculate commuteDistance and costDistance to compare with euclidean distance with the different options

# Lets work for 15 mins

# Graph based connectivity measures

## How does it work

* We generate a network of patches
* Each patch has attributes (Size, Diversity, Land use, etc)
* Each edge has attributes (Distance, conductivity/resistance)

## Pros and cons

::: {style="float: left; width: 50%;"}
**Pros**

* Computationally eficient
* Robust mathematical framework 
:::

::: {style="float: right; width: 50%;"}
**Cons**

* Generating the dataset as a network might not be as easy
* Networks are less intuitive
:::

## How to build your network {.smaller}

```{r firstpatches, cache=T}
library(sfnetworks)
Patches$ID <- 1:nrow(Patches)
Centroids$ID <- 1:nrow(Centroids)
Centroids_SF <- sf::st_as_sf(Centroids)
# Patches connected to 2000 meters
joins <- nearby(Patches, distance = 2000) |> as.data.frame() 


Edges <- purrr::map(1:nrow(joins), ~as.lines(rbind(Centroids[Centroids$ID == joins$from[.x],], Centroids[Centroids$ID == joins$to[.x],]))) |>
      purrr::reduce(rbind)

Edges$from <- joins$from
Edges$to <- joins$to

net <- sfnetworks::sfnetwork(nodes = Centroids_SF,
                      edges = sf::st_as_sf(Edges))
```

## Plot edges

```{r, cache=TRUE, echo=FALSE}
ggplot() + geom_spatvector(data = Edges)
```

## Plot Network

```{r, cache=TRUE, echo=FALSE}
autoplot(net, graticule = TRUE, axes = TRUE) + ggtitle("Edges: 2000")
```

## Several distances

```{r newedges, echo=FALSE, cache=TRUE, eval=FALSE}
library(patchwork)
Graphs <- list()

Distances <- c(2000, 5000, 10000)
for(i in 1:length(Distances)){
  Patches$ID <- 1:nrow(Patches)
Centroids$ID <- 1:nrow(Centroids)
Centroids_SF <- sf::st_as_sf(Centroids)
# Patches connected to 2000 meters
joins <- nearby(Patches, distance = Distances[i]) |> as.data.frame() 


Edges <- purrr::map(1:nrow(joins), ~as.lines(rbind(Centroids[Centroids$ID == joins$from[.x],], Centroids[Centroids$ID == joins$to[.x],]))) |>
      purrr::reduce(rbind)

Edges$from <- joins$from
Edges$to <- joins$to

net <- sfnetworks::sfnetwork(nodes = Centroids_SF,
                      edges = sf::st_as_sf(Edges))

saveRDS(net, paste0("net", Distances[i], ".rds"))

Graphs[[i]] <- autoplot(net) + labs(title = paste("Distance", Distances[i], "meters"), subtitle = paste(nrow(Edges), "edges"))

saveRDS(Graphs, paste0("Graphs", Distances[i], ".rds"))
}

```

```{r Patchwork, cache = T, echo=FALSE}
Graphs <- readRDS("Graphs5000.rds")
patchwork::wrap_plots(Graphs, nrow = 2)
```

# Network flow 

## Networks through time

* Changes in suitability through time

```{r, echo = F}
knitr::include_graphics("Images/NF1.png")
```

## Networks through time

* As a network

```{r, echo = F}
knitr::include_graphics("Images/NF2.png")
```


## Changing the dispersal

```{r, echo=FALSE}
knitr::include_graphics("Images/Dist.gif")
```

